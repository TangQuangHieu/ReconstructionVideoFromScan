/* -LICENSE-START-
** Copyright (c) 2021 Blackmagic Design
** Permission is hereby granted, free of charge, to any person or organization obtaining a copy
** of the software and accompanying documentation (the "Software") to use, reproduce,
** display, distribute, sub-license, execute, and transmit the Software, and to prepare
** derivative works of the Software, and to permit third-parties to whom the Software is
** furnished to do so, in accordance with:
**
** (1) if the Software is obtained from Blackmagic Design, the End User License Agreement for
** the Software Development Kit (“EULA”) available at
** https://downloads.blackmagicdesign.com/EULA/Cintel/Cintel-End-User-License-Agreement.pdf; or
**
** (2) if the Software is obtained from any third party, such licensing terms as notified by
** that third party,
** and all subject to the following:
**
** (3) the copyright notices in the Software and this entire statement, including the above
** license grant, this restriction and the following disclaimer, must be included in all copies
** of the Software, in whole or in part, and all derivative works of the Software, unless
** such copies or derivative works are solely in the form of machine-executable object code
** generated by a source language processor.
**
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
** DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
** TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
** OTHER DEALINGS IN THE SOFTWARE.
**
** A copy of the Software is available free of charge at
** https://www.blackmagicdesign.com/developer/product/cintel
**
** -LICENSE-END-
*/


#pragma once

#include <fstream>
#include <iostream>
#include <vector>
#include <array>
#include <numeric>

namespace KLV
{
	// Key and length are stored as little endian 32-bit unsigned integers, and value types are stored as
	// arrays of little endian 8-bit, 16-bit, 32-bit or 64-bit values.

	enum Key : uint32_t
	{
		Header				= 1,
		FrameInfo			= 100,		// [ width, height, ColorModel, Endianness ]
		CodecType			= 101,
		CodecName			= 102,		// used since Resolve 14.3 (Cintel 2.1) for compressed RAW files
		FrameData			= 103,		// pixel data (can be uncompressed or JPEG compressed)
		Negative			= 104,		// obsolete, replaced by FilmType
		FlipHorizontal		= 105,
		FlipVertical		= 106,
		FilmFrameRate		= 107,
		FilmType			= 108,
		LinearMask			= 109,		// 3 x 3
		TimeCode			= 110,
		FilmGauge			= 111,
		LogMask				= 112,		// 3 x 3
		OffsetDetectedH		= 113,		// integer stabilization in horizontal direction
		OffsetDetectedV		= 114,		// integer stabilization in vertical direction
		ExtendedRange		= 115,
		Keykode				= 116,
		StabilizerEnabledH	= 117,
		StabilizerEnabledV	= 118,
		TileSizes			= 119,		// 1 x 4, used since Resolve 14.3 (Cintel 2.1) for compressed RAW files
		Gains				= 120,		// 1 x 3
		Lifts				= 121,		// 1 x 3
		HDRGains			= 122,		// 1 x 3
		OffsetToApplyH		= 123,      // floating point sub-pixel stabilization in horizontal direction
		OffsetToApplyV		= 124,      // floating point sub-pixel stabilization in vertical direction
		SkewToApply			= 125,      // floating point skew
		Filler				= 1000,		// used by applications that require frame data to be aligned on a particular boundary
	};

	enum Endianness
	{
		ENDIAN_BIG		= 0,
		ENDIAN_LITTLE
	};

	enum ContainerCodecType
	{
		CODEC_TYPE_NONE	= 0,
		CODEC_TYPE_VIDEO
	};

	enum ColorModel
	{
		COLOR_MODEL_BAYER_GRGR_CINTEL_10 = 45,

		COLOR_MODEL_BAYER_BGGR_CINTEL_12 = 76,
		COLOR_MODEL_BAYER_GBGB_CINTEL_12 = 77,
		COLOR_MODEL_BAYER_RGRG_CINTEL_12 = 78,
		COLOR_MODEL_BAYER_GRGR_CINTEL_12 = 79,

		COLOR_MODEL_BAYER_BGGR_CINTEL_16 = 88,
		COLOR_MODEL_BAYER_GBGB_CINTEL_16 = 89,
		COLOR_MODEL_BAYER_RGRG_CINTEL_16 = 90,
		COLOR_MODEL_BAYER_GRGR_CINTEL_16 = 91,
	};

	const std::string		HEADER_STRING = "DVCC";
	const std::string		COMPRESSED_CODEC_NAME = "cintel_craw";

	// Reading

	inline bool readKeyLength(std::ifstream& file, Key& key, uint32_t& length)
	{
		file.read(reinterpret_cast<char*>(&key), sizeof(key));
		if (file.fail())
			return false;
		file.read(reinterpret_cast<char*>(&length), sizeof(length));
		if (file.fail())
			return false;
		return true;
	}

	template <typename T>
	inline auto readValue(std::ifstream& file, uint32_t length) -> std::vector<T>
	{
		std::vector<T> value(length / sizeof(T));

		file.read(reinterpret_cast<char*>(value.data()), length);
		if (file.fail())
			throw std::runtime_error("readValue: failed to read " + std::to_string(length) + " bytes");

		return value;
	}

	// Special case for reading a string since it's more convenient than a vector of char
	inline std::string readString(std::ifstream& file, uint32_t length)
	{
		const auto value = readValue<char>(file, length);
		return std::string(value.begin(), value.end());
	}

	// Writing

	inline void writeKeyLength(std::ofstream& file, Key key, size_t length)
	{
		uint32_t	len = uint32_t(length);
		file.write(reinterpret_cast<const char*>(&key), sizeof(Key));
		file.write(reinterpret_cast<const char*>(&len), sizeof(len));
	}

	template <typename T>
	inline void write(std::ofstream& file, Key key, const std::vector<T>& value)
	{
		size_t length = value.size() * sizeof(T);

		writeKeyLength(file, key, length);
		file.write(reinterpret_cast<const char*>(value.data()), length);
		if (file.fail())
			throw std::runtime_error("write: failed to write key " + std::to_string(key));
	}

	inline void write(std::ofstream& file, Key key, const std::string& value)
	{
		size_t length = value.length();

		writeKeyLength(file, key, length);
		file.write(value.c_str(), length);		// write string without any terminating NUL character
		if (file.fail())
			throw std::runtime_error("write: failed to write key " + std::to_string(key));
	}

	// Specialisation for writing data from a plain pointer (to avoid a copy when input is not a vector)
	inline void write(std::ofstream& file, Key key, size_t length, const uint8_t* data)
	{
		writeKeyLength(file, key, length);
		file.write(reinterpret_cast<const char*>(data), length);
		if (file.fail())
			throw std::runtime_error("write: failed to write key " + std::to_string(key));
	}

	// Specialisation for sparsely layed out tile data e.g. in a DeckLink frame containing compressed tiles
	inline void write(std::ofstream& file, Key key, size_t length, const uint8_t* data, const std::array<uint32_t, 4>& tileSize)
	{
		size_t allTilesSize = std::accumulate(tileSize.begin(), tileSize.end(), size_t(0));

		writeKeyLength(file, key, allTilesSize);
		const auto numTiles = tileSize.size();
		for (size_t tile = 0; tile < numTiles; tile++)
			file.write(reinterpret_cast<const char*>(data + length / numTiles * tile), tileSize.at(tile));
		if (file.fail())
			throw std::runtime_error("write: failed to write key " + std::to_string(key));
	}

	// Helper functions for dumping metadata to stream
	template <typename T>
	inline std::ostream& operator << (std::ostream& os, const std::vector<T>& v)
	{
		for (auto it = v.begin(); it != v.end(); ++it)
			os << *it << (std::distance(it, v.end()) == 1 ? "" : ", ");
		return os;
	}

	// This specialisation is required to avoid the STL outputting chars instead of integers
	inline std::ostream& operator << (std::ostream& os, const std::vector<uint8_t>& v)
	{
		for (auto it = v.begin(); it != v.end(); ++it)
			os << unsigned(*it) << (std::distance(it, v.end()) == 1 ? "" : ", ");
		return os;
	}

	// Utility function to dump the metadata from a CRI file without reading the entire file
	inline void dumpMetadata(const std::string& filename)
	{
		using namespace std;

		try
		{
			ifstream	file(filename, ifstream::binary);

			if (!file.is_open())
				throw std::runtime_error("Could not open file: " + filename);

			Key			key;
			uint32_t	length;

			while (KLV::readKeyLength(file, key, length))
			{
				switch (key)
				{
					case KLV::Header:				{ cout << "Header "			<< KLV::readString(file, length) << endl; break; }
					case KLV::FrameInfo:			{ cout << "FrameInfo "		<< KLV::readValue<uint32_t>(file, length) << endl; break; }
					case KLV::CodecType:			{ cout << "CodecType "		<< KLV::readValue<uint32_t>(file, length) << endl; break; }
					case KLV::CodecName:			{ cout << "CodecName "		<< KLV::readString(file, length) << endl; break; }
					case KLV::Negative:				{ cout << "Negative "		<< KLV::readValue<uint8_t>(file, length) << endl; break; }
					case KLV::FlipHorizontal:		{ cout << "FlipHorizontal "	<< KLV::readValue<uint8_t>(file, length) << endl; break; }
					case KLV::FlipVertical:			{ cout << "FlipVertical "	<< KLV::readValue<uint8_t>(file, length) << endl; break; }
					case KLV::FilmFrameRate:		{ cout << "FilmFrameRate "	<< KLV::readValue<float>(file, length) << endl; break; }
					case KLV::FilmType:				{ cout << "FilmType "		<< KLV::readValue<uint8_t>(file, length) << endl; break; }
					case KLV::LinearMask:			{ cout << "LinearMask "		<< KLV::readValue<float>(file, length) << endl; break; }
					case KLV::TimeCode:				{ cout << "Timecode "		<< KLV::readString(file, length) << endl; break; }
					case KLV::FilmGauge:			{ cout << "FilmGauge "		<< KLV::readValue<uint8_t>(file, length) << endl; break; }
					case KLV::LogMask:				{ cout << "LogMask "		<< KLV::readValue<float>(file, length) << endl; break; }
					case KLV::OffsetDetectedH:		{ cout << "OffsetDetectedH "<< KLV::readValue<int16_t>(file, length) << endl; break; }
					case KLV::OffsetDetectedV:		{ cout << "OffsetDetectedV "<< KLV::readValue<int16_t>(file, length) << endl; break; }
					case KLV::ExtendedRange:		{ cout << "ExtendedRange "	<< KLV::readValue<uint8_t>(file, length) << endl; break; }
					case KLV::Keykode:				{ cout << "Keykode "		<< KLV::readString(file, length) << endl; break; }
					case KLV::StabilizerEnabledH:	{ cout << "StabilizerEnabledH "	<< KLV::readValue<uint8_t>(file, length) << endl; break; }
					case KLV::StabilizerEnabledV:	{ cout << "StabilizerEnabledV "	<< KLV::readValue<uint8_t>(file, length) << endl; break; }
					case KLV::TileSizes:			{ cout << "TileSizes "		<< KLV::readValue<int64_t>(file, length) << endl; break; }
					case KLV::Gains:				{ cout << "Gains "			<< KLV::readValue<float>(file, length) << endl; break; }
					case KLV::Lifts:				{ cout << "Lifts "			<< KLV::readValue<float>(file, length) << endl; break; }
					case KLV::OffsetToApplyH:		{ cout << "OffsetToApplyH "	<< KLV::readValue<float>(file, length) << endl; break; }
					case KLV::OffsetToApplyV:		{ cout << "OffsetToApplyV "	<< KLV::readValue<float>(file, length) << endl; break; }
					case KLV::SkewToApply:			{ cout << "SkewToApply "	<< KLV::readValue<float>(file, length) << endl; break; }
					case KLV::Filler:				{ cout << "Filler ("	<< length << " bytes)" << endl; file.seekg(length, ios::cur); break; }
					case KLV::FrameData:			{ cout << "FrameData ("	<< length << " bytes)" << endl; file.seekg(length, ios::cur); break; }
					default:						{ file.seekg(length, ios::cur); break; }
				}
			}
		}
		catch (const exception& e)
		{
			cerr << "dumpMetadata failed for " << filename << ": " << e.what() << endl;
		}
	}
};
