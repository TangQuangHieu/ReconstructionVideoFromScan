/* -LICENSE-START-
** Copyright (c) 2021 Blackmagic Design
** Permission is hereby granted, free of charge, to any person or organization obtaining a copy
** of the software and accompanying documentation (the "Software") to use, reproduce,
** display, distribute, sub-license, execute, and transmit the Software, and to prepare
** derivative works of the Software, and to permit third-parties to whom the Software is
** furnished to do so, in accordance with:
**
** (1) if the Software is obtained from Blackmagic Design, the End User License Agreement for
** the Software Development Kit (“EULA”) available at
** https://downloads.blackmagicdesign.com/EULA/Cintel/Cintel-End-User-License-Agreement.pdf; or
**
** (2) if the Software is obtained from any third party, such licensing terms as notified by
** that third party,
** and all subject to the following:
**
** (3) the copyright notices in the Software and this entire statement, including the above
** license grant, this restriction and the following disclaimer, must be included in all copies
** of the Software, in whole or in part, and all derivative works of the Software, unless
** such copies or derivative works are solely in the form of machine-executable object code
** generated by a source language processor.
**
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
** DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
** TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
** OTHER DEALINGS IN THE SOFTWARE.
**
** A copy of the Software is available free of charge at
** https://www.blackmagicdesign.com/developer/product/cintel
**
** -LICENSE-END-
*/


#pragma once

// Platform independent replacement for CComPtr & CComQIPtr, that requires no ATL

#ifdef __APPLE__
	#include <CoreFoundation/CFPluginCOM.h>
	typedef CFUUIDBytes IID;
#elif defined(_WIN32)
	#ifndef NOMINMAX
		#define NOMINMAX
	#endif
	#ifndef WIN32_LEAN_AND_MEAN
		#define WIN32_LEAN_AND_MEAN
	#endif
	#include <Windows.h>
	#include <unknwn.h>
#elif defined(__linux__)
	#include "LinuxCOM.h"
	#include <cstddef>
#else
	#error Unsupported platform
#endif

#if !defined(_WIN32) && !defined(IID_IUnknown)
	const CFUUIDBytes IID_IUnknown = CFUUIDGetUUIDBytes(IUnknownUUID);
#endif


template<class T>
class COMPtr
{
public:
	COMPtr(REFIID iid = IID_IUnknown);
	COMPtr(T* local, REFIID refiid = IID_IUnknown);
	COMPtr(const COMPtr<T>& ptrCOM);
	COMPtr(REFIID refiid, IUnknown* unknown);
	~COMPtr();

	operator T*() const;
	// T** operator&(); DEPRECATED: Use outArg();
	T* operator->() const;
	COMPtr<T>& operator=(T* local);
	COMPtr<T>& operator=(const COMPtr<T>& ptrCOM);
	template<class Q> COMPtr<T>& operator=(const COMPtr<Q>& ptrCOM);

	// Implements ATL's CComPtrBase
	void Attach(T* local);		// The smart pointer takes ownership of the raw pointer
	T* Detach();				// The smart pointer releases ownership of the raw pointer
	void Release();
	bool IsEqualObject(IUnknown* test);

	// A replacement for operator&, which releases the original pointer first. This function is mainly only for
	// assignment as an 'out' parameter in a function call.
	T** outArg();

private:
	REFIID m_iid;
	T* m_ptr;
};


//-----------------------------------------------------------------------------

template<class T>
COMPtr<T>::COMPtr(REFIID iid)
: m_iid(iid),
m_ptr(NULL)
{
}


//-----------------------------------------------------------------------------

template<class T>
COMPtr<T>::COMPtr(T* local, REFIID iid)
: m_iid(iid),
m_ptr(local)
{
	if (m_ptr)
	{
		m_ptr->AddRef();
	}
}


//-----------------------------------------------------------------------------

template<class T>
COMPtr<T>::COMPtr(const COMPtr<T>& ptrCOM)
: m_iid(ptrCOM.m_iid),
m_ptr(ptrCOM.m_ptr)
{
	if (m_ptr)
	{
		m_ptr->AddRef();
	}
}


//-----------------------------------------------------------------------------

template<class T>
COMPtr<T>::COMPtr(REFIID iid, IUnknown* unknown)
: m_iid(iid),
m_ptr(NULL)
{
	if (unknown != NULL)
	{
		unknown->QueryInterface(iid, (void**)&m_ptr);
	}
}


//-----------------------------------------------------------------------------

template<class T>
COMPtr<T>::~COMPtr()
{
	if (m_ptr)
	{
		m_ptr->Release();
		m_ptr = NULL;
	}
}


//-----------------------------------------------------------------------------

template<class T>
COMPtr<T>::operator T*() const
{
	return m_ptr;
}


//-----------------------------------------------------------------------------

template<class T>
T* COMPtr<T>::operator->() const
{
	return m_ptr;
}


//-----------------------------------------------------------------------------

template<class T>
COMPtr<T>& COMPtr<T>::operator=(T* local)
{
	if(m_ptr != local)
	{
		if(m_ptr)
		{
			m_ptr->Release();
			m_ptr = NULL;
		}
		if(local)
		{
			m_ptr = local;
			m_ptr->AddRef();
		}
	}
	return *this;
}

//-----------------------------------------------------------------------------

template<class T>
COMPtr<T>& COMPtr<T>::operator=(const COMPtr<T>& ptrCOM)
{
	if (m_ptr != ptrCOM.m_ptr)
	{
		if (m_ptr)
		{
			m_ptr->Release();
		}
		m_ptr = ptrCOM.m_ptr;
		if (m_ptr)
		{
			m_ptr->AddRef();
		}
	}
	return *this;
}


//-----------------------------------------------------------------------------

template<class T>
template<class Q>
COMPtr<T>& COMPtr<T>::operator=(const COMPtr<Q>& ptrCOM)
{
	if (!IsEqualObject(ptrCOM))
	{
		ptrCOM->QueryInterface(m_iid, (void**)this->outArg());
	}
	return *this;
}


//-----------------------------------------------------------------------------

template<class T>
void COMPtr<T>::Attach(T* local)
{
	if (m_ptr)
	{
		m_ptr->Release();
	}
	m_ptr = local;
}


//-----------------------------------------------------------------------------

template<class T>
T* COMPtr<T>::Detach()
{
	T* ret = m_ptr;
	m_ptr = NULL;
	return ret;
}


//-----------------------------------------------------------------------------

template<class T>
void COMPtr<T>::Release()
{
	if (m_ptr)
	{
		m_ptr->Release();
		m_ptr = NULL;
	}
}


//-----------------------------------------------------------------------------

template<class T>
bool COMPtr<T>::IsEqualObject(IUnknown* test)
{
	if (m_ptr == NULL && test == NULL)
		return true;

	if (m_ptr == NULL || test == NULL)
		return false;

	COMPtr<IUnknown> myUnknown(IID_IUnknown, m_ptr);
	COMPtr<IUnknown> otherUnknown(IID_IUnknown, test);

	return (IUnknown*)myUnknown == (IUnknown*)otherUnknown;
}


//-----------------------------------------------------------------------------

template<class T>
T** COMPtr<T>::outArg()
{
	Release();
	return &m_ptr;
}
