/* -LICENSE-START-
** Copyright (c) 2021 Blackmagic Design
** Permission is hereby granted, free of charge, to any person or organization obtaining a copy
** of the software and accompanying documentation (the "Software") to use, reproduce,
** display, distribute, sub-license, execute, and transmit the Software, and to prepare
** derivative works of the Software, and to permit third-parties to whom the Software is
** furnished to do so, in accordance with:
**
** (1) if the Software is obtained from Blackmagic Design, the End User License Agreement for
** the Software Development Kit (“EULA”) available at
** https://downloads.blackmagicdesign.com/EULA/Cintel/Cintel-End-User-License-Agreement.pdf; or
**
** (2) if the Software is obtained from any third party, such licensing terms as notified by
** that third party,
** and all subject to the following:
**
** (3) the copyright notices in the Software and this entire statement, including the above
** license grant, this restriction and the following disclaimer, must be included in all copies
** of the Software, in whole or in part, and all derivative works of the Software, unless
** such copies or derivative works are solely in the form of machine-executable object code
** generated by a source language processor.
**
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
** DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
** TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
** OTHER DEALINGS IN THE SOFTWARE.
**
** A copy of the Software is available free of charge at
** https://www.blackmagicdesign.com/developer/product/cintel
**
** -LICENSE-END-
*/


#pragma once
#include <initializer_list>
#include <cstdint>
#include <vector>
#include <array>
#include <cmath>

class CintelRawImage;

#ifdef _WIN32
	#define EXPORTED	__declspec( dllexport )
#else
	#define EXPORTED	__attribute__((visibility("default")))
#endif

namespace ProcessImageUtil
{
	// Clamp for pre-C++17 compilers
	template <typename T>
	T clamp(const T& value, const T& low, const T& high) { return max(low, min(value, high)); }

	// Because process image library is built with clang++ and std:: symbols might be incompatible with g++, so use a simple transparent container
	// NOTE: Basic and simple usage, so runtimes underneath should be compatible, this simply overcomes linker errors for cross compilation
	struct vector_uint8_t_data		{const std::vector<uint8_t>& 	data;};
	struct vector_uint16_t_data		{const std::vector<uint16_t>& 	data;};
	struct array_vector_float_data	{const std::array<std::vector<float>, 3>& data;};
	struct array_uint32_t_tiles		{const std::array<uint32_t, 4>& data;};

	// Cintel CRAW/packing assist functions
	std::vector<uint16_t>	EXPORTED	decodeJPEGFrame(const vector_uint8_t_data& frame, unsigned width, unsigned height,
														const array_uint32_t_tiles& tileSizes, unsigned sparseTileOffset = 0);
	std::vector<uint16_t>	EXPORTED	unpackCintelVideoFrame12BitLegacyPacking(const vector_uint8_t_data& packed, uint32_t unpackedWidth, uint32_t unpackedHeight);
	std::vector<uint16_t>	EXPORTED	unpack12BitPackedFrame(const vector_uint8_t_data& data);
	std::vector<uint8_t>	EXPORTED	pack16BitUnpackedFrame(const vector_uint16_t_data& unpacked);

	// Save to TIFF easy handling
	void	EXPORTED	saveColorTIFF(unsigned width, unsigned height, const array_vector_float_data& rgbData, const char* filename, float scale = 65535.0f);
	void	EXPORTED	saveGrayscaleTIFF(unsigned width, unsigned height, const void* data, const char* filename);
}

enum class StabilizerMethod : uint8_t
{
	Rounded = 0,	// Faster
	SubPixel
};

enum class DebayerMethod : uint8_t
{
    HighQuality = 0,
    Simple		// Faster
};

enum class LogMaskingMethod : uint8_t
{
    NoScaleAndInvert = 0,
	ScaleAndInvert,
	NoScaleAndNoInvert,
	ScaleAndNoInvert
};

class ProcessImage
{
public:
	EXPORTED ProcessImage(const CintelRawImage& cri);

	void EXPORTED debayer(DebayerMethod quality = DebayerMethod::HighQuality);
	void EXPORTED linearMask();
	void EXPORTED logMask(LogMaskingMethod method = LogMaskingMethod::NoScaleAndInvert);
	void EXPORTED gains();
	void EXPORTED lifts();
	void EXPORTED applyStabilityOffsets(StabilizerMethod precision = StabilizerMethod::SubPixel, bool stabilize = true);
	void EXPORTED combineHDR(const ProcessImage& high);
	void EXPORTED applyBlankingAndFlips();

	const std::array<std::vector<float>, 3>	EXPORTED & getRgbFrame() const	{ return m_rgb; }

private:
	float mean2(int xOrigin, int yOrigin, int xOffset1, int yOffset1, int xOffset2, int yOffset2);
	float mean4(int xOrigin, int yOrigin, std::initializer_list<int> offsets);
	unsigned idx(unsigned x, unsigned y);

private:
	const CintelRawImage&				m_cri;
	const uint32_t						m_width;
	const uint32_t						m_height;
	std::vector<float>					m_data;
	std::array<int, 4>					m_blanking; // LRTB blanking
	std::array<std::vector<float>, 3>	m_rgb;
	
	// Exposed here so colour space details are transparent outside of ProcessImageLibrary
	float cintelLog(float pixel, bool usePrintLog)
	{
		// Not technically a 'gamma' in the normal sense but it's used the same way - this is from the Cineon
		// standard of 0.002 density units per stored DN (so at 10 bits it's 0.002 * 1023 = 2.046).
		// Note that earlier standards incorrectly state this as 2.048.
		const float		kCineonGamma	= 2.046f;
		const float		kFilmGammaNeg	= 1.0f / kCineonGamma;

		const float		kDisplayGamma	= 2.200f;
		const float		kFilmGammaPrint	= 1.0f / kDisplayGamma;

		const float		gamma = usePrintLog ? kFilmGammaPrint : kFilmGammaNeg;

		float a = 0.0f;
		float b = 1.0f;

		if (usePrintLog)
		{
			a = 1.0f / (std::pow(10.0f, 1.0f / gamma) - 1.0f);
			b = 1.0f - gamma * std::log10(1.0f  + a);
		}

		// One sided clamp to avoid negative or zero values before calling log function
		pixel = max(pixel, (0.0001f - a));

		// Apply log curve
		float logValue = gamma * std::log10(pixel + a) + b;

		// Clamp to a range a little larger than pixel range to provide headroom for other processing i.e. [-0.2, 1.2]
		return ProcessImageUtil::clamp(logValue, -0.2f, 1.2f);
	}
};
