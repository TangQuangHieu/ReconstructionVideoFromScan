/* -LICENSE-START-
** Copyright (c) 2021 Blackmagic Design
** Permission is hereby granted, free of charge, to any person or organization obtaining a copy
** of the software and accompanying documentation (the "Software") to use, reproduce,
** display, distribute, sub-license, execute, and transmit the Software, and to prepare
** derivative works of the Software, and to permit third-parties to whom the Software is
** furnished to do so, in accordance with:
**
** (1) if the Software is obtained from Blackmagic Design, the End User License Agreement for
** the Software Development Kit (“EULA”) available at
** https://downloads.blackmagicdesign.com/EULA/Cintel/Cintel-End-User-License-Agreement.pdf; or
**
** (2) if the Software is obtained from any third party, such licensing terms as notified by
** that third party,
** and all subject to the following:
**
** (3) the copyright notices in the Software and this entire statement, including the above
** license grant, this restriction and the following disclaimer, must be included in all copies
** of the Software, in whole or in part, and all derivative works of the Software, unless
** such copies or derivative works are solely in the form of machine-executable object code
** generated by a source language processor.
**
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
** DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
** TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
** OTHER DEALINGS IN THE SOFTWARE.
**
** A copy of the Software is available free of charge at
** https://www.blackmagicdesign.com/developer/product/cintel
**
** -LICENSE-END-
*/


#pragma once

#ifdef _WIN32
	#include <windows.h>
	#include <direct.h>
#else
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <dirent.h>
#endif
#include <cctype>
#include <fstream>

namespace
{
	// Utility funtions that use the filesystem. Provided for those compilers which do not have C++17's std::filesystem.
#ifdef _WIN32
	const char kPathSeparator	= '\\';
#else
	const char kPathSeparator	= '/';
#endif
	const std::string kHDRDirectoryName  = ".HDR";

	inline void makeSingleDir(const std::string& dir)
	{
	#ifdef _WIN32
		if (_mkdir(dir.c_str()) != 0)
		{
			errno_t err;

			_get_errno(&err);

			if (err == EEXIST) // Already exists, so continue
				return;

			throw std::runtime_error("Could not create directory: " + dir);
		}
	#else
		struct stat st;

		if (stat(dir.c_str(), &st) == 0)
		{
			if (S_ISDIR(st.st_mode))
				return;
			else
				throw std::runtime_error("\"" + dir + "\" exists but is not a directory");
		}

		if (mkdir(dir.c_str(), 0755) != 0)
			throw std::runtime_error("Could not create directory: " + dir);
	#endif
	}

	inline std::string toZeroPaddedString(int64_t number, int width)
	{
		std::string	numberStr = std::to_string(number);
		int			numZeroes = std::max(0, int(width - numberStr.length()));
		return std::string(numZeroes, '0').append(numberStr);
	}

	inline bool iequal(const std::string& s1, const std::string& s2)
	{
		return s1.length() == s2.length() &&
		std::equal(s1.begin(), s1.end(), s2.begin(),
				   [](int c1, int c2) { return std::toupper(c1) == std::toupper(c2); });
	}

#ifdef _WIN32
	inline std::vector<std::string> getCRIFilesFromDirectory(const std::string& directory)
	{
		std::string		pattern(directory);
		pattern.append("\\*.CRI");

		WIN32_FIND_DATA				data;
		HANDLE						hFind;
		std::vector<std::string>	files;

		if ((hFind = FindFirstFile(pattern.c_str(), &data)) != INVALID_HANDLE_VALUE)
		{
			do
			{
				files.emplace_back(directory + kPathSeparator + data.cFileName);
			} while (FindNextFile(hFind, &data) != 0);
			FindClose(hFind);
		}
		return files;
	}
#else
	inline std::vector<std::string> getCRIFilesFromDirectory(const std::string& directory)
	{
		DIR*		dir = opendir(directory.c_str());
		if (! dir)
			throw std::runtime_error("Cannot open directory " + directory);

		struct dirent*				dp;
		std::vector<std::string>	files;

		while ((dp = readdir(dir)) != nullptr)
		{
			std::string		filename(dp->d_name);

			auto pos = filename.rfind('.');
			if (pos != std::string::npos && iequal(filename.substr(pos), ".CRI"))
				files.emplace_back(directory + "/" + filename);
		}
		closedir(dir);
		return files;
	}
#endif

	// Replace a filename extension, including the '.', with a new extension including the '.'
	inline std::string replaceExtension(const std::string& filename, const std::string& newExtension)
	{
		std::string newFilename = filename;

		auto pos = filename.rfind('.');
		if (pos != std::string::npos && iequal(filename.substr(pos), ".CRI"))
			newFilename.replace(pos, newExtension.length(), newExtension);
		else
			newFilename += newExtension;
		return newFilename;
	}

	// Build an output filename from an output directory, a filename and an extension. E.g.
	// given "/path/output/", "/path/input/file.cri", "tiff"
	// returns "/path/output/file.tiff"
	inline std::string getOutputFilename(const std::string& outputDir, const std::string& filename, const std::string& ext)
	{
		if (filename.empty())
			throw std::runtime_error("Filename must not be empty");

		if (outputDir.empty())
			return replaceExtension(filename, ext);

		// Get basename of filename
		std::string	basename = filename;

		// Remove trailing path separators if any
		while (! basename.empty() && basename.back() == kPathSeparator)
			basename.pop_back();

		if (basename.empty())
			throw std::runtime_error("Filename must not be empty");

		const auto	pos = basename.rfind(kPathSeparator);
		if (pos != std::string::npos)
		{
			basename = filename.substr(pos + 1);
		}

		return outputDir + kPathSeparator + replaceExtension(basename, ext);
	}

	// Build an HDR filename from an input filename E.g. given "/path/file.cri"
	// returns "/path/.HDR/file.cri"
	inline std::string getHDRFilename(const std::string& filename)
	{
		if (filename.empty())
			throw std::runtime_error("Filename must not be empty");

		// Get basename of filename
		std::string	basename = filename;

		// Remove trailing path separators if any
		while (! basename.empty() && basename.back() == kPathSeparator)
			basename.pop_back();

		if (basename.empty())
			throw std::runtime_error("Filename must not be empty");

		std::string hdrname;

		const auto	pos = basename.rfind(kPathSeparator);
		if (pos != std::string::npos)
		{
			basename = filename.substr(pos + 1);
			hdrname = filename.substr(0, pos + 1);
			hdrname += kHDRDirectoryName;
			hdrname += kPathSeparator;
			hdrname += basename;
		}

		return hdrname;
	}

	template <typename T>
	void saveBinaryFile(const std::string& filename, const std::vector<T>& data)
	{
		std::ofstream file(filename, std::ofstream::binary);
		if (! file.is_open())
			throw std::runtime_error("Could not open file: " + filename);

		file.write((char *)data.data(), data.size() * sizeof(T));
		if (file.fail())
			throw std::runtime_error(filename + ": write failed");
	}

	template <typename T>
	void saveBinaryFileRGB(const std::string& filename, const std::array<std::vector<T>, 3>& data)
	{
		std::ofstream file(filename, std::ofstream::binary);
		if (! file.is_open())
			throw std::runtime_error("Could not open file: " + filename);

		for (auto color : data)
		{
			file.write((char *)color.data(), color.size() * sizeof(T));

			if (file.fail())
				throw std::runtime_error(filename + ": write failed");
		}
	}
}
