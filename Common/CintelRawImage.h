/* -LICENSE-START-
** Copyright (c) 2021 Blackmagic Design
** Permission is hereby granted, free of charge, to any person or organization obtaining a copy
** of the software and accompanying documentation (the "Software") to use, reproduce,
** display, distribute, sub-license, execute, and transmit the Software, and to prepare
** derivative works of the Software, and to permit third-parties to whom the Software is
** furnished to do so, in accordance with:
**
** (1) if the Software is obtained from Blackmagic Design, the End User License Agreement for
** the Software Development Kit (“EULA”) available at
** https://downloads.blackmagicdesign.com/EULA/Cintel/Cintel-End-User-License-Agreement.pdf; or
**
** (2) if the Software is obtained from any third party, such licensing terms as notified by
** that third party,
** and all subject to the following:
**
** (3) the copyright notices in the Software and this entire statement, including the above
** license grant, this restriction and the following disclaimer, must be included in all copies
** of the Software, in whole or in part, and all derivative works of the Software, unless
** such copies or derivative works are solely in the form of machine-executable object code
** generated by a source language processor.
**
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
** DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT,
** TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
** OTHER DEALINGS IN THE SOFTWARE.
**
** A copy of the Software is available free of charge at
** https://www.blackmagicdesign.com/developer/product/cintel
**
** -LICENSE-END-
*/


#pragma once

#include <cstdint>
#include <string>
#include <vector>
#include <array>

#include "COMPtr.h"
#include "ScannerAPI.h"

// This class represents a Cintel Raw Image (CRI) file used by DaVinci Resolve to store captured
// film frames and their associated metadata from a Cintel Scanner. This metadata is required
// to process the frame's image to an RGB color image for display or further processing.
// See the ProcessImage sample for an example of how to process a CRI file.
//
class CintelRawImage
{
public:
	CintelRawImage(COMPtr<IScannerInputFrame> deckLinkVideoFrame);		// used when capturing from a scanner
	CintelRawImage(const std::string& filename);						// used when reading a CRI file

	// Save to a CRI file e.g. used when recording DeckLink captured frames to disk
	void						save(const std::string& filename) const;

	// Save as uncompressed CRI, decompressing frame data if necessary
	void						saveAsUncompressed(const std::string& filename) const;

	// Get an uncompressed frame of RAW 12-bit per pixel image sensor data with bayer pattern GRBG
	// as vector of uint16_t values for convenient access. This contains linear sensor data that
	// will need to be processed into an RGB image for display or further processing.
	std::vector<uint16_t>		getRawFrame() const;

	// Metadata

	enum class FilmType
	{
		Positive = 0,
		Negative = 1,
		InterPositive = 2,
		InterNegative = 3
	};

	enum class FilmGauge
	{
		Gauge16mm = 0,
		Gauge35mm2Perf = 1,
		Gauge35mm3Perf = 2,
		Gauge35mm4Perf = 3
	};

	unsigned					width() const						{ return m_width; }
	unsigned					height() const						{ return m_height; }
	FilmType					filmType() const					{ return m_filmType; }
	FilmGauge					filmGauge() const					{ return m_filmGauge; }
	float						filmFrameRate() const				{ return m_filmFrameRate; }
	float						offsetToApplyHorizontal() const		{ return m_offsetToApplyHorizontal; }
	float						offsetToApplyVertical() const		{ return m_offsetToApplyVertical; }
	std::array<float, 9>		linearMask() const					{ return m_linearMask; }
	std::array<float, 9>		logMask() const						{ return m_logMask; }
	std::array<float, 3>		gains() const						{ return m_gains; }
	std::array<float, 3>		lifts() const						{ return m_lifts; }
	bool						flipHorizontal() const				{ return m_flipHorizontal; }
	bool						flipVertical() const				{ return m_flipVertical; }
	uint32_t					timeCodeBCD() const					{ return m_timeCodeBCD; }
	std::string					keykode() const						{ return m_keykode; }
	std::array<float, 3>		hdrGains() const					{ return m_hdrGains; }

private:
	void						writeMetadataAndFiller(std::ofstream& file, bool isCompressed) const;

	COMPtr<IScannerInputFrame>	m_deckLinkFrame		{ nullptr };

	std::vector<uint16_t>		m_rawFrame;			// RAW 12-bit per pixel image sensor data decompressed/unpacked into 16-bit type

	// Metadata which maps directly to fields in a CRI file.
	// A std::runtime_error exception is thrown on construction if required fields are not present.
	unsigned					m_width;					// required
	unsigned					m_height;					// required
	FilmType					m_filmType;					// required
	FilmGauge					m_filmGauge;				// required
	float						m_filmFrameRate;			// required
	float						m_offsetToApplyHorizontal	{ 0.0 };
	float						m_offsetToApplyVertical		{ 0.0 };
	float						m_skewToApply				{ 0.0 };
	std::array<uint32_t, 4>		m_tileSize					= std::array<uint32_t, 4> {{ 0, 0, 0, 0 }};
	std::array<float, 9>		m_linearMask;				// required
	std::array<float, 9>		m_logMask;					// required
	std::array<float, 3>		m_gains						= std::array<float, 3> {{ 1.0, 1.0, 1.0 }};
	std::array<float, 3>		m_lifts						= std::array<float, 3> {{ 0.0, 0.0, 0.0 }};
	bool						m_flipHorizontal			{ false };
	bool						m_flipVertical				{ true };		// default is true due to physical arrangement of image sensor
	uint32_t					m_timeCodeBCD				{ 0x01000000 };
	std::string					m_keykode;
	std::array<float, 3>		m_hdrGains					= std::array<float, 3> {{ 1.0, 1.0, 1.0 }};
	uint32_t					m_colorModel				{ 0 };

	// Derived information
	bool						m_isCompressed				{ false };
};

